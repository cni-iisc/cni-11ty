export function activatePopup(...args: any[]): Popup;
/**
 * Implement the popup handler.
 */
declare class Popup {
    /**
     * Initialize a new `Popup` instance.
     * @param {HTMLButtonElement} anchorElement - `<button>` element that triggers the popup.
     * @param {HTMLDialogElement} popupElement - `<dialog>` element to be used for the popup.
     * @param {import('../typedefs').PopupPosition} position - Where to show the popup content.
     * @param {HTMLElement} [positionBaseElement] - The base element of the `position`. If omitted,
     * this will be the `anchorElement`.
     */
    constructor(anchorElement: HTMLButtonElement, popupElement: HTMLDialogElement, position: import("../typedefs").PopupPosition, positionBaseElement?: HTMLElement | undefined);
    open: import("svelte/store").Writable<boolean>;
    /**
     * @type {import('svelte/store').Writable<{
     * inset: string | undefined,
     * zIndex: number | undefined,
     * minWidth: string | undefined,
     * maxWidth: string | undefined,
     * height: string | undefined,
     * }>}
     */
    style: import("svelte/store").Writable<{
        inset: string | undefined;
        zIndex: number | undefined;
        minWidth: string | undefined;
        maxWidth: string | undefined;
        height: string | undefined;
    }>;
    observer: IntersectionObserver;
    anchorElement: HTMLButtonElement;
    popupElement: HTMLDialogElement;
    position: import("../typedefs").PopupPosition;
    positionBaseElement: HTMLElement;
    id: string;
    /**
     * Whether the anchor element is disabled.
     * @type {boolean}
     */
    get isDisabled(): boolean;
    /**
     * Whether the anchor element is read-only.
     * @type {boolean}
     */
    get isReadOnly(): boolean;
    /**
     * Check the position of the anchor element.
     */
    checkPosition(): void;
    /**
     * Hide the popup immediately (when the anchor is being hidden).
     */
    hideImmediately(): Promise<void>;
}
export {};
